# -*- coding: utf-8 -*-
"""RID214533_Desafio05.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UUNTf7kgxwyQqKj6rkpuX-4JhsxbqgaK

# Etapa 01: Leitura e Inspeção dos Dados
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import chardet

with open("data.csv", "rb") as f:
  result = chardet.detect(f.read())

encoding = result["encoding"]
confidence = result["confidence"]

print(f"Codificação detectada: {encoding} com confiança {confidence}")

try:
  df = pd.read_csv("data.csv", encoding=encoding)
  print("Arquivo lido com sucesso!")
except Exception as e:
  print(f"Erro ao decodificar o arquivo: {e}")

print(df.head())
print(df.info())
print(df.describe())

"""# Etapa 02: Tratamento de Valores Faltantes na Identificação de Cliente"""

print("CustomerID nulos: ", df['CustomerID'].isnull().sum())

df.dropna(subset=['CustomerID'], inplace=True)

print("CustomerID nulos após remoção: ", df['CustomerID'].isnull().sum())

"""# Etapa 03: Tratamento de Preços e Quantidades Inválidos"""

df = df[df['UnitPrice'] > 0]

df = df[df['Quantity'] > 0]

print(df.describe())

"""# Etapa 04: Remoção de Linhas Duplicadas"""

print("Quantidade de linhas duplicadas: ",df.duplicated().sum())

df.drop_duplicates(inplace=True)

print("Quantidade de linhas duplicadas após tratamento: ",df.duplicated().sum())

"""# Etapa 05: Correção dos Tipos de Dados"""

df['CustomerID'] = df['CustomerID'].astype(int)

df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'])

print(df.info())

"""# Etapa 06: Tratamento de Outliers"""

df = df[df['Quantity'] <= 10000]
df = df[df['UnitPrice'] <= 5000]

"""# Etapa 07: Criação da Coluna de Preço Total"""

df['TotalPrice'] = df['Quantity'] * df['UnitPrice']

"""# Etapa 08: Cálculo da Última Coluna"""

last_date = df['InvoiceDate'].max()

print(f"Data mais recente: {last_date}")

"""# Etapa 09: Plotagem de Gráficos"""

# Top 10 países por valor de vendas
plt.figure(figsize=(10, 6))
df.groupby('Country')['TotalPrice'].sum().nlargest(10).plot(kind='bar')
plt.title('Top 10 Países por Valor de Vendas')
plt.show()

# Top 10 produtos mais vendidos
plt.figure(figsize=(10, 6))
df.groupby('Description')['Quantity'].sum().nlargest(10).plot(kind='bar')
plt.title('Top 10 Produtos Mais Vendidos')
plt.show()

# Valor de venda total por mês
plt.figure(figsize=(10, 6))
df.set_index('InvoiceDate')['TotalPrice'].resample('ME').sum().plot()
plt.title('Valor de Venda Total por Mês')
plt.show()

# Valor de venda total por mês e por país (top 10)
top_10_conuntries = df.groupby('Country')['TotalPrice'].sum().nlargest(10).index
plt.figure(figsize=(12, 8))
for country in top_10_conuntries:
  df_country = df[df['Country'] == country]
  df_country.set_index('InvoiceDate')['TotalPrice'].resample('ME').sum().plot(label=country)
plt.title('Valor de Venda Total por Mês e por País (top 10)')
plt.legend()
plt.show()

"""# Etapa 10: Cálculo do RFM"""

customer_invoice_data = df.groupby(['CustomerID', 'InvoiceNo']).agg({'InvoiceDate': 'max', 'TotalPrice': 'sum'})
customer_invoice_data.columns = ['InvoiceDate', 'TotalOrderValue']
customer_invoice_data.reset_index(inplace=True)

# Calculando RFM
rfm = customer_invoice_data.groupby('CustomerID').agg({
    'InvoiceDate': lambda x: (last_date - x.max()).days,
    'InvoiceNo': 'count',
    'TotalOrderValue': 'sum'
})

rfm.columns = ['Recency', 'Frequency', 'Monetary']

# Exporta o resultado para um arquivo CSV
rfm.to_csv('rfm_output.csv')